# Описание модулей:

## main

Данный код представляет собой простое приложение Flask, которое запускает веб-сервер и определяет маршруты для обработки HTTP-запросов.

Первым шагом импортируется класс Flask из модуля flask. Затем импортируется переменная app из модуля routes (предположительно, это модуль, содержащий определения маршрутов для приложения).

Далее создается экземпляр класса Flask и присваивается переменной app. В качестве аргумента конструктору передается __name__, что указывает Flask на то, что это основной модуль или пакет.

Затем вызывается метод register_blueprint() на объекте app, чтобы зарегистрировать маршруты из модуля routes_app. Регистрация маршрутов позволяет приложению знать, как обрабатывать входящие HTTP-запросы.

Наконец, проверяется, является ли текущий модуль основным модулем, вызывая __name__ == '__main__'. Если это так, то приложение запускается с помощью метода run() на объекте app. В данном случае, включен режим отладки (debug=True) и сервер будет слушать порт 7000.

Таким образом, этот код создает Flask-приложение, регистрирует маршруты и запускает сервер для обработки HTTP-запросов.

## connection

Данный код относится к работе с базой данных в приложении, используя SQLAlchemy.

Сначала импортируются необходимые модули: dbname_app, user_app, password_app, host_app, port_app из модуля modules.security, а также sessionmaker и create_engine из модуля sqlalchemy.

Далее определяется строка подключения к базе данных DATABASE_URL с использованием значений, полученных из user_app, password_app, host_app, port_app и dbname_app. Эта строка будет содержать информацию, необходимую для установления соединения с базой данных PostgreSQL.

Затем создается экземпляр класса Engine из модуля create_engine и передается ему DATABASE_URL в качестве аргумента. Этот объект engine представляет собой основной интерфейс к базе данных и будет использоваться для выполнения SQL-запросов.

Наконец, создается класс Session с использованием sessionmaker, который связывается с engine. Этот класс будет использоваться для создания отдельных сессий (экземпляров) для каждого подключения к базе данных. Сессии позволяют выполнять операции чтения и записи данных в базу данных.

Таким образом, данный код устанавливает соединение с базой данных PostgreSQL с помощью SQLAlchemy и создает класс Session, который будет использоваться для управления подключениями к базе данных в приложении.

## models

Здесь определяется схема базы данных с использованием SQLAlchemy.
Она включает определение таблиц и их отношений, а также создание таблиц в базе данных.

Сначала импортируются необходимые модули: DeclarativeBase, relationship, Column, String, Integer, SmallInteger, Numeric, Boolean, DateTime, ForeignKey из модуля sqlalchemy.orm и text из модуля sqlalchemy.sql.expression. Также импортируется объект engine из модуля modules.connection, который представляет собой движок SQLAlchemy, созданный ранее.

Затем определяется класс Base, который является базовым классом для всех моделей в базе данных. Он наследуется от DeclarativeBase и не содержит дополнительных полей или методов.

Далее определяются модели данных, каждая из которых является подклассом Base:

Модель Users представляет таблицу "users" в базе данных. Она содержит следующие поля:

id: целочисленное поле, являющееся первичным ключом таблицы.
login: строковое поле, содержащее имя пользователя. Не может быть пустым и должно быть уникальным.
psw: строковое поле, содержащее пароль пользователя. Не может быть пустым.
access_level: целочисленное поле, содержащее уровень доступа пользователя. По умолчанию равно 1.
Модель Customers представляет таблицу "customers" в базе данных. Она содержит следующие поля:

id: целочисленное поле, являющееся первичным ключом таблицы.
name_cust: строковое поле, содержащее имя клиента. Не может быть пустым и должно быть уникальным.
is_deleted: булево поле, указывающее, удален ли клиент. По умолчанию равно False.
Также определена связь accounts с моделью Accounts через отношение relationship.

Модель Accounts представляет таблицу "accounts" в базе данных. Она содержит следующие поля:

id: целочисленное поле, являющееся первичным ключом таблицы.
cust_id: целочисленное поле, являющееся внешним ключом, связанным с полем id в таблице "customers".
account_number: строковое поле, содержащее номер счета клиента. Не может быть пустым и должно быть уникальным.
is_deleted: булево поле, указывающее, удален ли счет. По умолчанию равно False.
date_deleted: поле даты и времени, указывающее дату удаления счета (может быть пустым).
amount: числовое поле, содержащее сумму на счете. По умолчанию равно 10000.
Также определена связь customer с моделью Customers через отношение relationship.

Наконец, вызывается метод create_all() на Base.metadata с передачей engine в качестве аргумента. Это создает все определенные модели таблиц в базе данных, если они еще не существуют.

Таким образом, данный код определяет схему базы данных с тремя таблицами: "users", "customers" и "accounts", и создает эти таблицы в базе данных, используя SQLAlchemy.

## routes

Данный код представляет собой приложение Flask на языке Python, которое реализует набор API-маршрутов для управления счетами клиентов.

Вначале импортируются необходимые модули: random для генерации случайных чисел, modules.repository для доступа к функциям работы с данными, Accounts из модуля modules.models для работы с объектами счетов, jsonify и request из Flask для обработки запросов и формирования ответов, а также render_template для отображения HTML-шаблонов.

Затем создается объект Blueprint с именем 'routes', который будет использоваться для определения маршрутов приложения.

Маршруты определены с помощью декоратора @app.route(). Например, маршрут '/' и '/home/' отвечают за отображение шаблона 'index.html' при GET-запросах. Маршрут '/deleted_accounts/' возвращает все удаленные счета клиентов. Маршруты '/accounts/' и '/acc/' возвращают все счета клиентов. Маршрут '/customers/int:id/accounts/' возвращает все счета для определенного клиента. Маршрут '/customers/int:id/' используется для добавления нового счета клиенту. Маршрут '/accounts/string:account_number/' используется для удаления счета по его номеру. Маршрут '/withdrawal/' выполняет операцию снятия средств со счета. Маршрут '/refill/' выполняет операцию пополнения счета. Маршрут '/transfer/' выполняет операцию перевода средств между двумя счетами.

Каждый маршрут вызывает соответствующие функции из модуля modules.repository для выполнения требуемых операций с данными. Результаты операций форматируются в JSON-ответы и возвращаются клиенту с соответствующими статусами ответов.

## repository

Предоставленный код содержит функции, которые взаимодействуют с базой данных с использованием SQLAlchemy для выполнения операций, связанных с клиентскими счетами. Вот краткое описание функций на русском языке:

get_all_accounts(_is_deleted=False): Получает все счета из базы данных. Принимает необязательный параметр _is_deleted, чтобы фильтровать удаленные счета.

get_customer_by_id(_id): Получает клиента по его идентификатору из базы данных. Проверяет, что клиент не удален.

get_accounts_by_cust_id(_id): Получает все счета, связанные с идентификатором клиента, из базы данных. Проверяет, что счета не удалены.

get_max_account_number(): Получает максимальный номер счета из базы данных.

add_accounts(_account_add): Добавляет новый счет в базу данных. Принимает параметр _account_add, который представляет собой добавляемый счет.

get_account_by_number(_account_number): Получает счет по его номеру из базы данных. Проверяет, что счет не удален.

del_account(_account_number): Удаляет счет по его номеру из базы данных. Помечает счет как удаленный.

update_account_balance(_account_number, _new_balance): Обновляет баланс счета по его номеру в базе данных.

## templates/index.html

Выводится (возвращается) в случае homepage

## README.md

Этот файл с комментариями...

* ###
